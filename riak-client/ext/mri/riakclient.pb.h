// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riakclient.proto

#ifndef PROTOBUF_riakclient_2eproto__INCLUDED
#define PROTOBUF_riakclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riakclient_2eproto();
void protobuf_AssignDesc_riakclient_2eproto();
void protobuf_ShutdownFile_riakclient_2eproto();

class RpbErrorResp;
class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetServerInfoResp;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbGetBucketReq;
class RpbGetBucketResp;
class RpbSetBucketReq;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbContent;
class RpbPair;
class RpbLink;
class RpbBucketProps;

// ===================================================================

class RpbErrorResp : public ::google::protobuf::Message {
 public:
  RpbErrorResp();
  virtual ~RpbErrorResp();
  
  RpbErrorResp(const RpbErrorResp& from);
  
  inline RpbErrorResp& operator=(const RpbErrorResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbErrorResp& default_instance();
  
  void Swap(RpbErrorResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbErrorResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbErrorResp& from);
  void MergeFrom(const RpbErrorResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes errmsg = 1;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 1;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const void* value, size_t size);
  inline ::std::string* mutable_errmsg();
  
  // required uint32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:RpbErrorResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* errmsg_;
  static const ::std::string _default_errmsg_;
  ::google::protobuf::uint32 errcode_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbErrorResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetClientIdResp : public ::google::protobuf::Message {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();
  
  RpbGetClientIdResp(const RpbGetClientIdResp& from);
  
  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetClientIdResp& default_instance();
  
  void Swap(RpbGetClientIdResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetClientIdResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  
  // @@protoc_insertion_point(class_scope:RpbGetClientIdResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* client_id_;
  static const ::std::string _default_client_id_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::Message {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();
  
  RpbSetClientIdReq(const RpbSetClientIdReq& from);
  
  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetClientIdReq& default_instance();
  
  void Swap(RpbSetClientIdReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetClientIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  
  // @@protoc_insertion_point(class_scope:RpbSetClientIdReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* client_id_;
  static const ::std::string _default_client_id_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetServerInfoResp : public ::google::protobuf::Message {
 public:
  RpbGetServerInfoResp();
  virtual ~RpbGetServerInfoResp();
  
  RpbGetServerInfoResp(const RpbGetServerInfoResp& from);
  
  inline RpbGetServerInfoResp& operator=(const RpbGetServerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetServerInfoResp& default_instance();
  
  void Swap(RpbGetServerInfoResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetServerInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetServerInfoResp& from);
  void MergeFrom(const RpbGetServerInfoResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  
  // optional bytes server_version = 2;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 2;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const void* value, size_t size);
  inline ::std::string* mutable_server_version();
  
  // @@protoc_insertion_point(class_scope:RpbGetServerInfoResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* node_;
  static const ::std::string _default_node_;
  ::std::string* server_version_;
  static const ::std::string _default_server_version_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetServerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::Message {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();
  
  RpbGetReq(const RpbGetReq& from);
  
  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetReq& default_instance();
  
  void Swap(RpbGetReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:RpbGetReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::google::protobuf::uint32 r_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::Message {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();
  
  RpbGetResp(const RpbGetResp& from);
  
  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetResp& default_instance();
  
  void Swap(RpbGetResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  
  // @@protoc_insertion_point(class_scope:RpbGetResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  static const ::std::string _default_vclock_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::Message {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();
  
  RpbPutReq(const RpbPutReq& from);
  
  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutReq& default_instance();
  
  void Swap(RpbPutReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  
  // required .RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::RpbContent& content() const;
  inline ::RpbContent* mutable_content();
  
  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);
  
  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);
  
  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbPutReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* vclock_;
  static const ::std::string _default_vclock_;
  ::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  bool return_body_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::Message {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();
  
  RpbPutResp(const RpbPutResp& from);
  
  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutResp& default_instance();
  
  void Swap(RpbPutResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  
  // @@protoc_insertion_point(class_scope:RpbPutResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  static const ::std::string _default_vclock_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::Message {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();
  
  RpbDelReq(const RpbDelReq& from);
  
  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbDelReq& default_instance();
  
  void Swap(RpbDelReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:RpbDelReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::google::protobuf::uint32 rw_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::Message {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();
  
  RpbListBucketsResp(const RpbListBucketsResp& from);
  
  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsResp& default_instance();
  
  void Swap(RpbListBucketsResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListBucketsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();
  
  // @@protoc_insertion_point(class_scope:RpbListBucketsResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::Message {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();
  
  RpbListKeysReq(const RpbListKeysReq& from);
  
  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysReq& default_instance();
  
  void Swap(RpbListKeysReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // @@protoc_insertion_point(class_scope:RpbListKeysReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::Message {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();
  
  RpbListKeysResp(const RpbListKeysResp& from);
  
  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysResp& default_instance();
  
  void Swap(RpbListKeysResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbListKeysResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketReq();
  virtual ~RpbGetBucketReq();
  
  RpbGetBucketReq(const RpbGetBucketReq& from);
  
  inline RpbGetBucketReq& operator=(const RpbGetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketReq& default_instance();
  
  void Swap(RpbGetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketReq& from);
  void MergeFrom(const RpbGetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // @@protoc_insertion_point(class_scope:RpbGetBucketReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketResp();
  virtual ~RpbGetBucketResp();
  
  RpbGetBucketResp(const RpbGetBucketResp& from);
  
  inline RpbGetBucketResp& operator=(const RpbGetBucketResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketResp& default_instance();
  
  void Swap(RpbGetBucketResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketResp& from);
  void MergeFrom(const RpbGetBucketResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .RpbBucketProps props = 1;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 1;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  
  // @@protoc_insertion_point(class_scope:RpbGetBucketResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::RpbBucketProps* props_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbGetBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketReq : public ::google::protobuf::Message {
 public:
  RpbSetBucketReq();
  virtual ~RpbSetBucketReq();
  
  RpbSetBucketReq(const RpbSetBucketReq& from);
  
  inline RpbSetBucketReq& operator=(const RpbSetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetBucketReq& default_instance();
  
  void Swap(RpbSetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetBucketReq& from);
  void MergeFrom(const RpbSetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // required .RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::RpbBucketProps& props() const;
  inline ::RpbBucketProps* mutable_props();
  
  // @@protoc_insertion_point(class_scope:RpbSetBucketReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  ::RpbBucketProps* props_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbSetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::Message {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();
  
  RpbMapRedReq(const RpbMapRedReq& from);
  
  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedReq& default_instance();
  
  void Swap(RpbMapRedReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  
  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  
  // @@protoc_insertion_point(class_scope:RpbMapRedReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* request_;
  static const ::std::string _default_request_;
  ::std::string* content_type_;
  static const ::std::string _default_content_type_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::Message {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();
  
  RpbMapRedResp(const RpbMapRedResp& from);
  
  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedResp& default_instance();
  
  void Swap(RpbMapRedResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);
  
  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  
  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbMapRedResp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 phase_;
  ::std::string* response_;
  static const ::std::string _default_response_;
  bool done_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::Message {
 public:
  RpbContent();
  virtual ~RpbContent();
  
  RpbContent(const RpbContent& from);
  
  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbContent& default_instance();
  
  void Swap(RpbContent* other);
  
  // implements Message ----------------------------------------------
  
  RpbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  
  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  
  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  
  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  
  // repeated .RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::RpbLink& links(int index) const;
  inline ::RpbLink* mutable_links(int index);
  inline ::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
      mutable_links();
  
  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);
  
  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);
  
  // repeated .RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::RpbPair& usermeta(int index) const;
  inline ::RpbPair* mutable_usermeta(int index);
  inline ::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_usermeta();
  
  // @@protoc_insertion_point(class_scope:RpbContent)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* content_type_;
  static const ::std::string _default_content_type_;
  ::std::string* charset_;
  static const ::std::string _default_charset_;
  ::std::string* content_encoding_;
  static const ::std::string _default_content_encoding_;
  ::std::string* vtag_;
  static const ::std::string _default_vtag_;
  ::google::protobuf::RepeatedPtrField< ::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > usermeta_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbPair : public ::google::protobuf::Message {
 public:
  RpbPair();
  virtual ~RpbPair();
  
  RpbPair(const RpbPair& from);
  
  inline RpbPair& operator=(const RpbPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPair& default_instance();
  
  void Swap(RpbPair* other);
  
  // implements Message ----------------------------------------------
  
  RpbPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPair& from);
  void MergeFrom(const RpbPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:RpbPair)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbPair* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::Message {
 public:
  RpbLink();
  virtual ~RpbLink();
  
  RpbLink(const RpbLink& from);
  
  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbLink& default_instance();
  
  void Swap(RpbLink* other);
  
  // implements Message ----------------------------------------------
  
  RpbLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  
  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // @@protoc_insertion_point(class_scope:RpbLink)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bucket_;
  static const ::std::string _default_bucket_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketProps : public ::google::protobuf::Message {
 public:
  RpbBucketProps();
  virtual ~RpbBucketProps();
  
  RpbBucketProps(const RpbBucketProps& from);
  
  inline RpbBucketProps& operator=(const RpbBucketProps& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketProps& default_instance();
  
  void Swap(RpbBucketProps* other);
  
  // implements Message ----------------------------------------------
  
  RpbBucketProps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketProps& from);
  void MergeFrom(const RpbBucketProps& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 n_val = 1;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 1;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);
  
  // optional bool allow_mult = 2;
  inline bool has_allow_mult() const;
  inline void clear_allow_mult();
  static const int kAllowMultFieldNumber = 2;
  inline bool allow_mult() const;
  inline void set_allow_mult(bool value);
  
  // @@protoc_insertion_point(class_scope:RpbBucketProps)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 n_val_;
  bool allow_mult_;
  friend void  protobuf_AddDesc_riakclient_2eproto();
  friend void protobuf_AssignDesc_riakclient_2eproto();
  friend void protobuf_ShutdownFile_riakclient_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RpbBucketProps* default_instance_;
};
// ===================================================================


// ===================================================================

// RpbErrorResp

// required bytes errmsg = 1;
inline bool RpbErrorResp::has_errmsg() const {
  return _has_bit(0);
}
inline void RpbErrorResp::clear_errmsg() {
  if (errmsg_ != &_default_errmsg_) {
    errmsg_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbErrorResp::errmsg() const {
  return *errmsg_;
}
inline void RpbErrorResp::set_errmsg(const ::std::string& value) {
  _set_bit(0);
  if (errmsg_ == &_default_errmsg_) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const char* value) {
  _set_bit(0);
  if (errmsg_ == &_default_errmsg_) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const void* value, size_t size) {
  _set_bit(0);
  if (errmsg_ == &_default_errmsg_) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbErrorResp::mutable_errmsg() {
  _set_bit(0);
  if (errmsg_ == &_default_errmsg_) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}

// required uint32 errcode = 2;
inline bool RpbErrorResp::has_errcode() const {
  return _has_bit(1);
}
inline void RpbErrorResp::clear_errcode() {
  errcode_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 RpbErrorResp::errcode() const {
  return errcode_;
}
inline void RpbErrorResp::set_errcode(::google::protobuf::uint32 value) {
  _set_bit(1);
  errcode_ = value;
}

// -------------------------------------------------------------------

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return _has_bit(0);
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &_default_client_id_) {
    client_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return _has_bit(0);
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &_default_client_id_) {
    client_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  _set_bit(0);
  if (client_id_ == &_default_client_id_) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}

// -------------------------------------------------------------------

// RpbGetServerInfoResp

// optional bytes node = 1;
inline bool RpbGetServerInfoResp::has_node() const {
  return _has_bit(0);
}
inline void RpbGetServerInfoResp::clear_node() {
  if (node_ != &_default_node_) {
    node_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbGetServerInfoResp::node() const {
  return *node_;
}
inline void RpbGetServerInfoResp::set_node(const ::std::string& value) {
  _set_bit(0);
  if (node_ == &_default_node_) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const char* value) {
  _set_bit(0);
  if (node_ == &_default_node_) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const void* value, size_t size) {
  _set_bit(0);
  if (node_ == &_default_node_) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_node() {
  _set_bit(0);
  if (node_ == &_default_node_) {
    node_ = new ::std::string;
  }
  return node_;
}

// optional bytes server_version = 2;
inline bool RpbGetServerInfoResp::has_server_version() const {
  return _has_bit(1);
}
inline void RpbGetServerInfoResp::clear_server_version() {
  if (server_version_ != &_default_server_version_) {
    server_version_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbGetServerInfoResp::server_version() const {
  return *server_version_;
}
inline void RpbGetServerInfoResp::set_server_version(const ::std::string& value) {
  _set_bit(1);
  if (server_version_ == &_default_server_version_) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const char* value) {
  _set_bit(1);
  if (server_version_ == &_default_server_version_) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const void* value, size_t size) {
  _set_bit(1);
  if (server_version_ == &_default_server_version_) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_server_version() {
  _set_bit(1);
  if (server_version_ == &_default_server_version_) {
    server_version_ = new ::std::string;
  }
  return server_version_;
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbGetReq::bucket() const {
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return _has_bit(1);
}
inline void RpbGetReq::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbGetReq::key() const {
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return _has_bit(2);
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  _set_bit(2);
  r_ = value;
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbGetResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbGetResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbGetResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbGetResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbGetResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return _has_bit(1);
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &_default_vclock_) {
    vclock_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbGetResp::vclock() const {
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const char* value) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbPutReq::bucket() const {
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// required bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return _has_bit(1);
}
inline void RpbPutReq::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbPutReq::key() const {
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return _has_bit(2);
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &_default_vclock_) {
    vclock_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RpbPutReq::vclock() const {
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  _set_bit(2);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const char* value) {
  _set_bit(2);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  _set_bit(2);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  _set_bit(2);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}

// required .RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return _has_bit(3);
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::RpbContent::Clear();
  _clear_bit(3);
}
inline const ::RpbContent& RpbPutReq::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::RpbContent* RpbPutReq::mutable_content() {
  _set_bit(3);
  if (content_ == NULL) content_ = new ::RpbContent;
  return content_;
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return _has_bit(4);
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  _set_bit(4);
  w_ = value;
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return _has_bit(5);
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  _set_bit(5);
  dw_ = value;
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return _has_bit(6);
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  _clear_bit(6);
}
inline bool RpbPutReq::return_body() const {
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  _set_bit(6);
  return_body_ = value;
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbPutResp::content(int index) const {
  return content_.Get(index);
}
inline ::RpbContent* RpbPutResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::RpbContent* RpbPutResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbPutResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbPutResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return _has_bit(1);
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &_default_vclock_) {
    vclock_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbPutResp::vclock() const {
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const char* value) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  _set_bit(1);
  if (vclock_ == &_default_vclock_) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbDelReq::bucket() const {
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return _has_bit(1);
}
inline void RpbDelReq::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbDelReq::key() const {
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return _has_bit(2);
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  _set_bit(2);
  rw_ = value;
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  return &buckets_;
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return _has_bit(1);
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  _clear_bit(1);
}
inline bool RpbListKeysResp::done() const {
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  _set_bit(1);
  done_ = value;
}

// -------------------------------------------------------------------

// RpbGetBucketReq

// required bytes bucket = 1;
inline bool RpbGetBucketReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbGetBucketReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbGetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbGetBucketReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetBucketReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// -------------------------------------------------------------------

// RpbGetBucketResp

// required .RpbBucketProps props = 1;
inline bool RpbGetBucketResp::has_props() const {
  return _has_bit(0);
}
inline void RpbGetBucketResp::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  _clear_bit(0);
}
inline const ::RpbBucketProps& RpbGetBucketResp::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbGetBucketResp::mutable_props() {
  _set_bit(0);
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}

// -------------------------------------------------------------------

// RpbSetBucketReq

// required bytes bucket = 1;
inline bool RpbSetBucketReq::has_bucket() const {
  return _has_bit(0);
}
inline void RpbSetBucketReq::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbSetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbSetBucketReq::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetBucketReq::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// required .RpbBucketProps props = 2;
inline bool RpbSetBucketReq::has_props() const {
  return _has_bit(1);
}
inline void RpbSetBucketReq::clear_props() {
  if (props_ != NULL) props_->::RpbBucketProps::Clear();
  _clear_bit(1);
}
inline const ::RpbBucketProps& RpbSetBucketReq::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::RpbBucketProps* RpbSetBucketReq::mutable_props() {
  _set_bit(1);
  if (props_ == NULL) props_ = new ::RpbBucketProps;
  return props_;
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return _has_bit(0);
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &_default_request_) {
    request_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbMapRedReq::request() const {
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  _set_bit(0);
  if (request_ == &_default_request_) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const char* value) {
  _set_bit(0);
  if (request_ == &_default_request_) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  _set_bit(0);
  if (request_ == &_default_request_) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  _set_bit(0);
  if (request_ == &_default_request_) {
    request_ = new ::std::string;
  }
  return request_;
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return _has_bit(1);
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &_default_content_type_) {
    content_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return _has_bit(0);
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  _set_bit(0);
  phase_ = value;
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return _has_bit(1);
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &_default_response_) {
    response_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbMapRedResp::response() const {
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  _set_bit(1);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const char* value) {
  _set_bit(1);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  _set_bit(1);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  _set_bit(1);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  return response_;
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return _has_bit(2);
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  _clear_bit(2);
}
inline bool RpbMapRedResp::done() const {
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  _set_bit(2);
  done_ = value;
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return _has_bit(0);
}
inline void RpbContent::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbContent::value() const {
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const void* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return _has_bit(1);
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &_default_content_type_) {
    content_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbContent::content_type() const {
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const char* value) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_type() {
  _set_bit(1);
  if (content_type_ == &_default_content_type_) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return _has_bit(2);
}
inline void RpbContent::clear_charset() {
  if (charset_ != &_default_charset_) {
    charset_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RpbContent::charset() const {
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  _set_bit(2);
  if (charset_ == &_default_charset_) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const char* value) {
  _set_bit(2);
  if (charset_ == &_default_charset_) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  _set_bit(2);
  if (charset_ == &_default_charset_) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_charset() {
  _set_bit(2);
  if (charset_ == &_default_charset_) {
    charset_ = new ::std::string;
  }
  return charset_;
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return _has_bit(3);
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &_default_content_encoding_) {
    content_encoding_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RpbContent::content_encoding() const {
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  _set_bit(3);
  if (content_encoding_ == &_default_content_encoding_) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const char* value) {
  _set_bit(3);
  if (content_encoding_ == &_default_content_encoding_) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  _set_bit(3);
  if (content_encoding_ == &_default_content_encoding_) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  _set_bit(3);
  if (content_encoding_ == &_default_content_encoding_) {
    content_encoding_ = new ::std::string;
  }
  return content_encoding_;
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return _has_bit(4);
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &_default_vtag_) {
    vtag_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& RpbContent::vtag() const {
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  _set_bit(4);
  if (vtag_ == &_default_vtag_) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const char* value) {
  _set_bit(4);
  if (vtag_ == &_default_vtag_) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  _set_bit(4);
  if (vtag_ == &_default_vtag_) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_vtag() {
  _set_bit(4);
  if (vtag_ == &_default_vtag_) {
    vtag_ = new ::std::string;
  }
  return vtag_;
}

// repeated .RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::RpbLink& RpbContent::links(int index) const {
  return links_.Get(index);
}
inline ::RpbLink* RpbContent::mutable_links(int index) {
  return links_.Mutable(index);
}
inline ::RpbLink* RpbContent::add_links() {
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
RpbContent::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
RpbContent::mutable_links() {
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return _has_bit(6);
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  _set_bit(6);
  last_mod_ = value;
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return _has_bit(7);
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  _set_bit(7);
  last_mod_usecs_ = value;
}

// repeated .RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::RpbPair& RpbContent::usermeta(int index) const {
  return usermeta_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_usermeta(int index) {
  return usermeta_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_usermeta() {
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::usermeta() const {
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_usermeta() {
  return &usermeta_;
}

// -------------------------------------------------------------------

// RpbPair

// required bytes key = 1;
inline bool RpbPair::has_key() const {
  return _has_bit(0);
}
inline void RpbPair::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbPair::key() const {
  return *key_;
}
inline void RpbPair::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional bytes value = 2;
inline bool RpbPair::has_value() const {
  return _has_bit(1);
}
inline void RpbPair::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbPair::value() const {
  return *value_;
}
inline void RpbPair::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const void* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return _has_bit(0);
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &_default_bucket_) {
    bucket_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RpbLink::bucket() const {
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const char* value) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_bucket() {
  _set_bit(0);
  if (bucket_ == &_default_bucket_) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return _has_bit(1);
}
inline void RpbLink::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RpbLink::key() const {
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const void* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return _has_bit(2);
}
inline void RpbLink::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RpbLink::tag() const {
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  _set_bit(2);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const char* value) {
  _set_bit(2);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  _set_bit(2);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_tag() {
  _set_bit(2);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// -------------------------------------------------------------------

// RpbBucketProps

// optional uint32 n_val = 1;
inline bool RpbBucketProps::has_n_val() const {
  return _has_bit(0);
}
inline void RpbBucketProps::clear_n_val() {
  n_val_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RpbBucketProps::n_val() const {
  return n_val_;
}
inline void RpbBucketProps::set_n_val(::google::protobuf::uint32 value) {
  _set_bit(0);
  n_val_ = value;
}

// optional bool allow_mult = 2;
inline bool RpbBucketProps::has_allow_mult() const {
  return _has_bit(1);
}
inline void RpbBucketProps::clear_allow_mult() {
  allow_mult_ = false;
  _clear_bit(1);
}
inline bool RpbBucketProps::allow_mult() const {
  return allow_mult_;
}
inline void RpbBucketProps::set_allow_mult(bool value) {
  _set_bit(1);
  allow_mult_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riakclient_2eproto__INCLUDED
